package com.ibm.analytics.wsdPkgMetrics

import ammonite.ops._
import ammonite.ops.ImplicitWd._
import ImageService._
import MetricsService._
import scala.concurrent.{Await, Future}
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global
import scala.language.implicitConversions

/**
 * Define an "enumeration" for the platform types supported by WSD (that is, Mac and Windows).
 */
sealed trait Platform  { def name: String }
case object Mac extends Platform { val name = "Mac" }
case object Win extends Platform { val name = "Win" }

/**
 * This program gathers package metrics for the latest available WSD install image packages.  
 * The generated metrics are stored in the metrics database.
 *
 * This program is intended to be run once a day.
 */
object WSDPackageMetricsGenerator {
  def main(args: Array[String]): Unit = {
    println("Starting metrics generation...")

    /* Get the latest image IDs for the platforms supported by WSD (that is, Mac and Windows). 
     * Create tuples containing the platform identifier and image IDs.  Add the tuples to a 
     * vector so we can process them. */
    val imageDataVec = Vector( 
      (Mac, ImageService.latestImageID(Mac)), 
      (Win, ImageService.latestImageID(Win))
    )

    imageDataVec.foreach( (platform, id) => println( s"Latest image ID for ${platform} is ${id}" ))

    /* From the list of image IDs, create a new list with only the images that we haven't yet
     * gathered statistics for.  Associate a download path with each image. 
     * Note: "pwd" is the process working directory from Ammonite-Ops.  That is the base for
     * the absolute path we want to use for the download.
     */
    val newImageDataVec = for ( 
      (platform, id) <- imageDataVec if MetricsService.hasMetricsForImage(platform, id) == false ;
      path = Path( s"${pwd}/download/${platform}/${id}/${ImageService.imageFilename(platform, id)}" )
    )
    yield ( (platform, id, path) )

    newImageDataVec.foreach( (platform, id, path) => {
      println( s"Metrics are needed for ${id}" )
      println( s"  Download path is ${path}" )
    })

    /* Start the download process for each install package image that needs it.  The downloads
     * are run asynchronously.  We need to wait until the downloads are done before we can 
     * continue, so create a Future which contains a list of the Futures generated by the 
     * image service.  We do this so we can wait for all of them to complete.
     */
    val futureOfDownloadFutures = Future.sequence( 
      newImageDataVec.map( (platform, id, path) => ImageService.downloadImage(platform, id, path) )
    )

    /* Wait until we get the result of each Future, with a max wait of 1800 seconds (30 minutes).
     * Catch and notify any exceptions that occur during this process.
     */
    try {
      val awaitRes = Await.result( futureOfDownloadFutures, 1800 seconds )
      println( s"Downloads result is ${awaitRes}" )
    } catch {
      case e: Exception => e.printStackTrace()
    }

    /* Generate metrics for each new image and store them away.  Generating the metrics can take
     * some time, so we use Futures for this also.
     */
    val futureOfMetricsFutures = Future.sequence(
      newImageDataVec.map( (platform, id, path) => MetricsService.generateMetricsForImage(platform, id, path) )
    )
   
    /* Wait for the generate metrics step to complete.
     */
    try {
      val awaitRes = Await.result( futureOfMetricsFutures, 600 seconds )
      println( s"Metrics result is ${awaitRes}" )
    } catch {
      case e: Exception => e.printStackTrace()
    }

    println("Metrics generation done!")
  }
}

